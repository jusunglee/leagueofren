// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cacheAccount = `-- name: CacheAccount :exec
INSERT INTO riot_account_cache (game_name, tag_line, region, puuid, expires_at)
VALUES ($1, $2, $3, $4, NOW() + interval '24 hours')
ON CONFLICT (game_name, tag_line, region)
DO UPDATE SET puuid = $4, cached_at = NOW(), expires_at = NOW() + interval '24 hours'
`

type CacheAccountParams struct {
	GameName string `json:"game_name"`
	TagLine  string `json:"tag_line"`
	Region   string `json:"region"`
	Puuid    string `json:"puuid"`
}

func (q *Queries) CacheAccount(ctx context.Context, arg CacheAccountParams) error {
	_, err := q.db.Exec(ctx, cacheAccount,
		arg.GameName,
		arg.TagLine,
		arg.Region,
		arg.Puuid,
	)
	return err
}

const cacheGameStatus = `-- name: CacheGameStatus :exec
INSERT INTO riot_game_cache (puuid, region, in_game, game_id, participants, expires_at)
VALUES ($1, $2, $3, $4, $5, NOW() + interval '2 minutes')
ON CONFLICT (puuid, region)
DO UPDATE SET in_game = $3, game_id = $4, participants = $5, cached_at = NOW(), expires_at = NOW() + interval '2 minutes'
`

type CacheGameStatusParams struct {
	Puuid        string      `json:"puuid"`
	Region       string      `json:"region"`
	InGame       bool        `json:"in_game"`
	GameID       pgtype.Int8 `json:"game_id"`
	Participants []byte      `json:"participants"`
}

func (q *Queries) CacheGameStatus(ctx context.Context, arg CacheGameStatusParams) error {
	_, err := q.db.Exec(ctx, cacheGameStatus,
		arg.Puuid,
		arg.Region,
		arg.InGame,
		arg.GameID,
		arg.Participants,
	)
	return err
}

const countSubscriptionsByServer = `-- name: CountSubscriptionsByServer :one
SELECT COUNT(*)
FROM subscriptions
WHERE server_id = $1
`

func (q *Queries) CountSubscriptionsByServer(ctx context.Context, serverID string) (int64, error) {
	row := q.db.QueryRow(ctx, countSubscriptionsByServer, serverID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEval = `-- name: CreateEval :one
INSERT INTO evals (subscription_id, eval_status, discord_message_id, game_id)
VALUES ($1, $2, $3, $4)
RETURNING id, subscription_id, game_id, evaluated_at, eval_status, discord_message_id
`

type CreateEvalParams struct {
	SubscriptionID   int64       `json:"subscription_id"`
	EvalStatus       string      `json:"eval_status"`
	DiscordMessageID pgtype.Text `json:"discord_message_id"`
	GameID           pgtype.Int8 `json:"game_id"`
}

func (q *Queries) CreateEval(ctx context.Context, arg CreateEvalParams) (Eval, error) {
	row := q.db.QueryRow(ctx, createEval,
		arg.SubscriptionID,
		arg.EvalStatus,
		arg.DiscordMessageID,
		arg.GameID,
	)
	var i Eval
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.GameID,
		&i.EvaluatedAt,
		&i.EvalStatus,
		&i.DiscordMessageID,
	)
	return i, err
}

const createFeedback = `-- name: CreateFeedback :one
INSERT INTO feedback (discord_message_id, feedback_text)
VALUES ($1, $2)
RETURNING id, discord_message_id, feedback_text, created_at
`

type CreateFeedbackParams struct {
	DiscordMessageID string `json:"discord_message_id"`
	FeedbackText     string `json:"feedback_text"`
}

func (q *Queries) CreateFeedback(ctx context.Context, arg CreateFeedbackParams) (Feedback, error) {
	row := q.db.QueryRow(ctx, createFeedback, arg.DiscordMessageID, arg.FeedbackText)
	var i Feedback
	err := row.Scan(
		&i.ID,
		&i.DiscordMessageID,
		&i.FeedbackText,
		&i.CreatedAt,
	)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (discord_channel_id, lol_username, region, server_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (discord_channel_id, lol_username, region) DO NOTHING
RETURNING id, discord_channel_id, server_id, lol_username, region, created_at, last_evaluated_at
`

type CreateSubscriptionParams struct {
	DiscordChannelID string `json:"discord_channel_id"`
	LolUsername      string `json:"lol_username"`
	Region           string `json:"region"`
	ServerID         string `json:"server_id"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.DiscordChannelID,
		arg.LolUsername,
		arg.Region,
		arg.ServerID,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.DiscordChannelID,
		&i.ServerID,
		&i.LolUsername,
		&i.Region,
		&i.CreatedAt,
		&i.LastEvaluatedAt,
	)
	return i, err
}

const createTranslation = `-- name: CreateTranslation :one
INSERT INTO translations (username, translation, provider, model)
VALUES ($1, $2, $3, $4)
ON CONFLICT (username) DO UPDATE SET translation = $2, provider = $3, model = $4
RETURNING id, username, translation, provider, model, created_at
`

type CreateTranslationParams struct {
	Username    string `json:"username"`
	Translation string `json:"translation"`
	Provider    string `json:"provider"`
	Model       string `json:"model"`
}

func (q *Queries) CreateTranslation(ctx context.Context, arg CreateTranslationParams) (Translation, error) {
	row := q.db.QueryRow(ctx, createTranslation,
		arg.Username,
		arg.Translation,
		arg.Provider,
		arg.Model,
	)
	var i Translation
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Translation,
		&i.Provider,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}

const createTranslationToEval = `-- name: CreateTranslationToEval :exec
INSERT INTO translation_to_evals (translation_id, eval_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type CreateTranslationToEvalParams struct {
	TranslationID int64 `json:"translation_id"`
	EvalID        int64 `json:"eval_id"`
}

func (q *Queries) CreateTranslationToEval(ctx context.Context, arg CreateTranslationToEvalParams) error {
	_, err := q.db.Exec(ctx, createTranslationToEval, arg.TranslationID, arg.EvalID)
	return err
}

const deleteEvals = `-- name: DeleteEvals :execrows
DELETE FROM evals
WHERE evaluated_at < $1
`

func (q *Queries) DeleteEvals(ctx context.Context, evaluatedAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteEvals, evaluatedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteExpiredAccountCache = `-- name: DeleteExpiredAccountCache :exec
DELETE FROM riot_account_cache WHERE expires_at < NOW()
`

// Cleanup queries
func (q *Queries) DeleteExpiredAccountCache(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredAccountCache)
	return err
}

const deleteExpiredGameCache = `-- name: DeleteExpiredGameCache :exec
DELETE FROM riot_game_cache WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredGameCache(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredGameCache)
	return err
}

const deleteOldFeedback = `-- name: DeleteOldFeedback :execrows
DELETE FROM feedback WHERE created_at < $1
`

func (q *Queries) DeleteOldFeedback(ctx context.Context, createdAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldFeedback, createdAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOldTranslations = `-- name: DeleteOldTranslations :execrows
DELETE FROM translations WHERE created_at < $1
`

func (q *Queries) DeleteOldTranslations(ctx context.Context, createdAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldTranslations, createdAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSubscription = `-- name: DeleteSubscription :execrows
DELETE FROM subscriptions
WHERE discord_channel_id = $1 AND lol_username = $2 AND region = $3
`

type DeleteSubscriptionParams struct {
	DiscordChannelID string `json:"discord_channel_id"`
	LolUsername      string `json:"lol_username"`
	Region           string `json:"region"`
}

func (q *Queries) DeleteSubscription(ctx context.Context, arg DeleteSubscriptionParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSubscription, arg.DiscordChannelID, arg.LolUsername, arg.Region)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSubscriptions = `-- name: DeleteSubscriptions :execrows
DELETE FROM subscriptions
WHERE id=ANY($1::bigint[])
`

func (q *Queries) DeleteSubscriptions(ctx context.Context, dollar_1 []int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSubscriptions, dollar_1)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findSubscriptionsWithExpiredNewestOnlineEval = `-- name: FindSubscriptionsWithExpiredNewestOnlineEval :many
SELECT subscription_id, MAX(evaluated_at) as newest_online_eval
FROM evals
WHERE eval_status != 'OFFLINE'
GROUP BY subscription_id
HAVING MAX(evaluated_at) < $1
`

type FindSubscriptionsWithExpiredNewestOnlineEvalRow struct {
	SubscriptionID   int64       `json:"subscription_id"`
	NewestOnlineEval interface{} `json:"newest_online_eval"`
}

func (q *Queries) FindSubscriptionsWithExpiredNewestOnlineEval(ctx context.Context, evaluatedAt pgtype.Timestamptz) ([]FindSubscriptionsWithExpiredNewestOnlineEvalRow, error) {
	rows, err := q.db.Query(ctx, findSubscriptionsWithExpiredNewestOnlineEval, evaluatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindSubscriptionsWithExpiredNewestOnlineEvalRow{}
	for rows.Next() {
		var i FindSubscriptionsWithExpiredNewestOnlineEvalRow
		if err := rows.Scan(&i.SubscriptionID, &i.NewestOnlineEval); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubscriptions = `-- name: GetAllSubscriptions :many
SELECT id, discord_channel_id, server_id, lol_username, region, created_at, last_evaluated_at FROM subscriptions
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) GetAllSubscriptions(ctx context.Context, limit int32) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getAllSubscriptions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.DiscordChannelID,
			&i.ServerID,
			&i.LolUsername,
			&i.Region,
			&i.CreatedAt,
			&i.LastEvaluatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCachedAccount = `-- name: GetCachedAccount :one
SELECT game_name, tag_line, region, puuid
FROM riot_account_cache
WHERE game_name = $1 AND tag_line = $2 AND region = $3 AND expires_at > NOW()
`

type GetCachedAccountParams struct {
	GameName string `json:"game_name"`
	TagLine  string `json:"tag_line"`
	Region   string `json:"region"`
}

type GetCachedAccountRow struct {
	GameName string `json:"game_name"`
	TagLine  string `json:"tag_line"`
	Region   string `json:"region"`
	Puuid    string `json:"puuid"`
}

// Account cache queries
func (q *Queries) GetCachedAccount(ctx context.Context, arg GetCachedAccountParams) (GetCachedAccountRow, error) {
	row := q.db.QueryRow(ctx, getCachedAccount, arg.GameName, arg.TagLine, arg.Region)
	var i GetCachedAccountRow
	err := row.Scan(
		&i.GameName,
		&i.TagLine,
		&i.Region,
		&i.Puuid,
	)
	return i, err
}

const getCachedGameStatus = `-- name: GetCachedGameStatus :one
SELECT puuid, region, in_game, game_id, participants
FROM riot_game_cache
WHERE puuid = $1 AND region = $2 AND expires_at > NOW()
`

type GetCachedGameStatusParams struct {
	Puuid  string `json:"puuid"`
	Region string `json:"region"`
}

type GetCachedGameStatusRow struct {
	Puuid        string      `json:"puuid"`
	Region       string      `json:"region"`
	InGame       bool        `json:"in_game"`
	GameID       pgtype.Int8 `json:"game_id"`
	Participants []byte      `json:"participants"`
}

// Game cache queries
func (q *Queries) GetCachedGameStatus(ctx context.Context, arg GetCachedGameStatusParams) (GetCachedGameStatusRow, error) {
	row := q.db.QueryRow(ctx, getCachedGameStatus, arg.Puuid, arg.Region)
	var i GetCachedGameStatusRow
	err := row.Scan(
		&i.Puuid,
		&i.Region,
		&i.InGame,
		&i.GameID,
		&i.Participants,
	)
	return i, err
}

const getEvalByGameAndSubscription = `-- name: GetEvalByGameAndSubscription :one
SELECT id, subscription_id, game_id, evaluated_at, eval_status, discord_message_id FROM evals
WHERE game_id = $1 AND subscription_id = $2
LIMIT 1
`

type GetEvalByGameAndSubscriptionParams struct {
	GameID         pgtype.Int8 `json:"game_id"`
	SubscriptionID int64       `json:"subscription_id"`
}

func (q *Queries) GetEvalByGameAndSubscription(ctx context.Context, arg GetEvalByGameAndSubscriptionParams) (Eval, error) {
	row := q.db.QueryRow(ctx, getEvalByGameAndSubscription, arg.GameID, arg.SubscriptionID)
	var i Eval
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.GameID,
		&i.EvaluatedAt,
		&i.EvalStatus,
		&i.DiscordMessageID,
	)
	return i, err
}

const getLatestEvalForSubscription = `-- name: GetLatestEvalForSubscription :one
SELECT id, subscription_id, game_id, evaluated_at, eval_status, discord_message_id FROM evals
WHERE subscription_id = $1
ORDER BY evaluated_at DESC
LIMIT 1
`

func (q *Queries) GetLatestEvalForSubscription(ctx context.Context, subscriptionID int64) (Eval, error) {
	row := q.db.QueryRow(ctx, getLatestEvalForSubscription, subscriptionID)
	var i Eval
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.GameID,
		&i.EvaluatedAt,
		&i.EvalStatus,
		&i.DiscordMessageID,
	)
	return i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, discord_channel_id, server_id, lol_username, region, created_at, last_evaluated_at FROM subscriptions
WHERE id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id int64) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.DiscordChannelID,
		&i.ServerID,
		&i.LolUsername,
		&i.Region,
		&i.CreatedAt,
		&i.LastEvaluatedAt,
	)
	return i, err
}

const getSubscriptionsByChannel = `-- name: GetSubscriptionsByChannel :many
SELECT id, discord_channel_id, server_id, lol_username, region, created_at, last_evaluated_at FROM subscriptions
WHERE discord_channel_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetSubscriptionsByChannel(ctx context.Context, discordChannelID string) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByChannel, discordChannelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.DiscordChannelID,
			&i.ServerID,
			&i.LolUsername,
			&i.Region,
			&i.CreatedAt,
			&i.LastEvaluatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslation = `-- name: GetTranslation :one
SELECT id, username, translation, provider, model, created_at FROM translations
WHERE username = $1
`

func (q *Queries) GetTranslation(ctx context.Context, username string) (Translation, error) {
	row := q.db.QueryRow(ctx, getTranslation, username)
	var i Translation
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Translation,
		&i.Provider,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}

const getTranslations = `-- name: GetTranslations :many
SELECT id, username, translation, provider, model, created_at FROM translations
WHERE username = ANY($1::text[])
`

func (q *Queries) GetTranslations(ctx context.Context, dollar_1 []string) ([]Translation, error) {
	rows, err := q.db.Query(ctx, getTranslations, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Translation{}
	for rows.Next() {
		var i Translation
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Translation,
			&i.Provider,
			&i.Model,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslationsForEval = `-- name: GetTranslationsForEval :many
SELECT t.id, t.username, t.translation, t.provider, t.model, t.created_at
FROM translations t
JOIN translation_to_evals tte ON t.id = tte.translation_id
WHERE tte.eval_id = $1
`

func (q *Queries) GetTranslationsForEval(ctx context.Context, evalID int64) ([]Translation, error) {
	rows, err := q.db.Query(ctx, getTranslationsForEval, evalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Translation{}
	for rows.Next() {
		var i Translation
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Translation,
			&i.Provider,
			&i.Model,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscriptionLastEvaluatedAt = `-- name: UpdateSubscriptionLastEvaluatedAt :exec
UPDATE subscriptions
SET last_evaluated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateSubscriptionLastEvaluatedAt(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateSubscriptionLastEvaluatedAt, id)
	return err
}
