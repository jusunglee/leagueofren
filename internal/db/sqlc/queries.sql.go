// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cacheAccount = `-- name: CacheAccount :exec
INSERT INTO riot_account_cache (game_name, tag_line, region, puuid, expires_at)
VALUES ($1, $2, $3, $4, NOW() + interval '24 hours')
ON CONFLICT (game_name, tag_line, region)
DO UPDATE SET puuid = $4, cached_at = NOW(), expires_at = NOW() + interval '24 hours'
`

type CacheAccountParams struct {
	GameName string `json:"game_name"`
	TagLine  string `json:"tag_line"`
	Region   string `json:"region"`
	Puuid    string `json:"puuid"`
}

func (q *Queries) CacheAccount(ctx context.Context, arg CacheAccountParams) error {
	_, err := q.db.Exec(ctx, cacheAccount,
		arg.GameName,
		arg.TagLine,
		arg.Region,
		arg.Puuid,
	)
	return err
}

const cacheGameStatus = `-- name: CacheGameStatus :exec
INSERT INTO riot_game_cache (puuid, region, in_game, game_id, participants, expires_at)
VALUES ($1, $2, $3, $4, $5, NOW() + interval '2 minutes')
ON CONFLICT (puuid, region)
DO UPDATE SET in_game = $3, game_id = $4, participants = $5, cached_at = NOW(), expires_at = NOW() + interval '2 minutes'
`

type CacheGameStatusParams struct {
	Puuid        string      `json:"puuid"`
	Region       string      `json:"region"`
	InGame       bool        `json:"in_game"`
	GameID       pgtype.Int8 `json:"game_id"`
	Participants []byte      `json:"participants"`
}

func (q *Queries) CacheGameStatus(ctx context.Context, arg CacheGameStatusParams) error {
	_, err := q.db.Exec(ctx, cacheGameStatus,
		arg.Puuid,
		arg.Region,
		arg.InGame,
		arg.GameID,
		arg.Participants,
	)
	return err
}

const countPublicFeedback = `-- name: CountPublicFeedback :one
SELECT COUNT(*) FROM public_feedback
`

func (q *Queries) CountPublicFeedback(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPublicFeedback)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublicTranslations = `-- name: CountPublicTranslations :one
SELECT COUNT(*)
FROM public_translations pt
JOIN players p ON pt.player_username = p.username
WHERE ($1::text = '' OR p.region = $1)
  AND ($2::text = '' OR pt.language = $2)
`

type CountPublicTranslationsParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
}

func (q *Queries) CountPublicTranslations(ctx context.Context, arg CountPublicTranslationsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPublicTranslations, arg.Column1, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubscriptionsByServer = `-- name: CountSubscriptionsByServer :one
SELECT COUNT(*)
FROM subscriptions
WHERE server_id = $1
`

func (q *Queries) CountSubscriptionsByServer(ctx context.Context, serverID string) (int64, error) {
	row := q.db.QueryRow(ctx, countSubscriptionsByServer, serverID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEval = `-- name: CreateEval :one
INSERT INTO evals (subscription_id, eval_status, discord_message_id, game_id)
VALUES ($1, $2, $3, $4)
RETURNING id, subscription_id, game_id, evaluated_at, eval_status, discord_message_id
`

type CreateEvalParams struct {
	SubscriptionID   int64       `json:"subscription_id"`
	EvalStatus       string      `json:"eval_status"`
	DiscordMessageID pgtype.Text `json:"discord_message_id"`
	GameID           pgtype.Int8 `json:"game_id"`
}

func (q *Queries) CreateEval(ctx context.Context, arg CreateEvalParams) (Eval, error) {
	row := q.db.QueryRow(ctx, createEval,
		arg.SubscriptionID,
		arg.EvalStatus,
		arg.DiscordMessageID,
		arg.GameID,
	)
	var i Eval
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.GameID,
		&i.EvaluatedAt,
		&i.EvalStatus,
		&i.DiscordMessageID,
	)
	return i, err
}

const createFeedback = `-- name: CreateFeedback :one
INSERT INTO feedback (discord_message_id, feedback_text)
VALUES ($1, $2)
RETURNING id, discord_message_id, feedback_text, created_at
`

type CreateFeedbackParams struct {
	DiscordMessageID string `json:"discord_message_id"`
	FeedbackText     string `json:"feedback_text"`
}

func (q *Queries) CreateFeedback(ctx context.Context, arg CreateFeedbackParams) (Feedback, error) {
	row := q.db.QueryRow(ctx, createFeedback, arg.DiscordMessageID, arg.FeedbackText)
	var i Feedback
	err := row.Scan(
		&i.ID,
		&i.DiscordMessageID,
		&i.FeedbackText,
		&i.CreatedAt,
	)
	return i, err
}

const createPublicFeedback = `-- name: CreatePublicFeedback :one
INSERT INTO public_feedback (translation_id, ip_hash, feedback_text)
VALUES ($1, $2, $3)
RETURNING id, translation_id, ip_hash, feedback_text, created_at
`

type CreatePublicFeedbackParams struct {
	TranslationID int64  `json:"translation_id"`
	IpHash        string `json:"ip_hash"`
	FeedbackText  string `json:"feedback_text"`
}

func (q *Queries) CreatePublicFeedback(ctx context.Context, arg CreatePublicFeedbackParams) (PublicFeedback, error) {
	row := q.db.QueryRow(ctx, createPublicFeedback, arg.TranslationID, arg.IpHash, arg.FeedbackText)
	var i PublicFeedback
	err := row.Scan(
		&i.ID,
		&i.TranslationID,
		&i.IpHash,
		&i.FeedbackText,
		&i.CreatedAt,
	)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (discord_channel_id, lol_username, region, server_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (discord_channel_id, lol_username, region) DO NOTHING
RETURNING id, discord_channel_id, server_id, lol_username, region, created_at, last_evaluated_at
`

type CreateSubscriptionParams struct {
	DiscordChannelID string `json:"discord_channel_id"`
	LolUsername      string `json:"lol_username"`
	Region           string `json:"region"`
	ServerID         string `json:"server_id"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.DiscordChannelID,
		arg.LolUsername,
		arg.Region,
		arg.ServerID,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.DiscordChannelID,
		&i.ServerID,
		&i.LolUsername,
		&i.Region,
		&i.CreatedAt,
		&i.LastEvaluatedAt,
	)
	return i, err
}

const createTranslation = `-- name: CreateTranslation :one
INSERT INTO translations (username, translation, provider, model)
VALUES ($1, $2, $3, $4)
ON CONFLICT (username) DO UPDATE SET translation = $2, provider = $3, model = $4
RETURNING id, username, translation, provider, model, created_at
`

type CreateTranslationParams struct {
	Username    string `json:"username"`
	Translation string `json:"translation"`
	Provider    string `json:"provider"`
	Model       string `json:"model"`
}

func (q *Queries) CreateTranslation(ctx context.Context, arg CreateTranslationParams) (Translation, error) {
	row := q.db.QueryRow(ctx, createTranslation,
		arg.Username,
		arg.Translation,
		arg.Provider,
		arg.Model,
	)
	var i Translation
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Translation,
		&i.Provider,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}

const createTranslationToEval = `-- name: CreateTranslationToEval :exec
INSERT INTO translation_to_evals (translation_id, eval_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type CreateTranslationToEvalParams struct {
	TranslationID int64 `json:"translation_id"`
	EvalID        int64 `json:"eval_id"`
}

func (q *Queries) CreateTranslationToEval(ctx context.Context, arg CreateTranslationToEvalParams) error {
	_, err := q.db.Exec(ctx, createTranslationToEval, arg.TranslationID, arg.EvalID)
	return err
}

const decrementDownvotes = `-- name: DecrementDownvotes :exec
UPDATE public_translations SET downvotes = downvotes - 1 WHERE id = $1
`

func (q *Queries) DecrementDownvotes(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, decrementDownvotes, id)
	return err
}

const decrementUpvotes = `-- name: DecrementUpvotes :exec
UPDATE public_translations SET upvotes = upvotes - 1 WHERE id = $1
`

func (q *Queries) DecrementUpvotes(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, decrementUpvotes, id)
	return err
}

const deleteEvals = `-- name: DeleteEvals :execrows
DELETE FROM evals
WHERE evaluated_at < $1
`

func (q *Queries) DeleteEvals(ctx context.Context, evaluatedAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteEvals, evaluatedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteExpiredAccountCache = `-- name: DeleteExpiredAccountCache :exec
DELETE FROM riot_account_cache WHERE expires_at < NOW()
`

// Cleanup queries
func (q *Queries) DeleteExpiredAccountCache(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredAccountCache)
	return err
}

const deleteExpiredGameCache = `-- name: DeleteExpiredGameCache :exec
DELETE FROM riot_game_cache WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredGameCache(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredGameCache)
	return err
}

const deleteOldFeedback = `-- name: DeleteOldFeedback :execrows
DELETE FROM feedback WHERE created_at < $1
`

func (q *Queries) DeleteOldFeedback(ctx context.Context, createdAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldFeedback, createdAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteOldTranslations = `-- name: DeleteOldTranslations :execrows
DELETE FROM translations WHERE created_at < $1
`

func (q *Queries) DeleteOldTranslations(ctx context.Context, createdAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldTranslations, createdAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSubscription = `-- name: DeleteSubscription :execrows
DELETE FROM subscriptions
WHERE discord_channel_id = $1 AND lol_username = $2 AND region = $3
`

type DeleteSubscriptionParams struct {
	DiscordChannelID string `json:"discord_channel_id"`
	LolUsername      string `json:"lol_username"`
	Region           string `json:"region"`
}

func (q *Queries) DeleteSubscription(ctx context.Context, arg DeleteSubscriptionParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSubscription, arg.DiscordChannelID, arg.LolUsername, arg.Region)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSubscriptions = `-- name: DeleteSubscriptions :execrows
DELETE FROM subscriptions
WHERE id=ANY($1::bigint[])
`

func (q *Queries) DeleteSubscriptions(ctx context.Context, dollar_1 []int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSubscriptions, dollar_1)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteVote = `-- name: DeleteVote :execrows
DELETE FROM votes WHERE translation_id = $1 AND ip_hash = $2
`

type DeleteVoteParams struct {
	TranslationID int64  `json:"translation_id"`
	IpHash        string `json:"ip_hash"`
}

func (q *Queries) DeleteVote(ctx context.Context, arg DeleteVoteParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteVote, arg.TranslationID, arg.IpHash)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findSubscriptionsWithExpiredNewestOnlineEval = `-- name: FindSubscriptionsWithExpiredNewestOnlineEval :many
SELECT subscription_id, MAX(evaluated_at) as newest_online_eval
FROM evals
WHERE eval_status != 'OFFLINE'
GROUP BY subscription_id
HAVING MAX(evaluated_at) < $1
`

type FindSubscriptionsWithExpiredNewestOnlineEvalRow struct {
	SubscriptionID   int64       `json:"subscription_id"`
	NewestOnlineEval interface{} `json:"newest_online_eval"`
}

func (q *Queries) FindSubscriptionsWithExpiredNewestOnlineEval(ctx context.Context, evaluatedAt pgtype.Timestamptz) ([]FindSubscriptionsWithExpiredNewestOnlineEvalRow, error) {
	rows, err := q.db.Query(ctx, findSubscriptionsWithExpiredNewestOnlineEval, evaluatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindSubscriptionsWithExpiredNewestOnlineEvalRow{}
	for rows.Next() {
		var i FindSubscriptionsWithExpiredNewestOnlineEvalRow
		if err := rows.Scan(&i.SubscriptionID, &i.NewestOnlineEval); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubscriptions = `-- name: GetAllSubscriptions :many
SELECT id, discord_channel_id, server_id, lol_username, region, created_at, last_evaluated_at FROM subscriptions
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) GetAllSubscriptions(ctx context.Context, limit int32) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getAllSubscriptions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.DiscordChannelID,
			&i.ServerID,
			&i.LolUsername,
			&i.Region,
			&i.CreatedAt,
			&i.LastEvaluatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCachedAccount = `-- name: GetCachedAccount :one
SELECT game_name, tag_line, region, puuid
FROM riot_account_cache
WHERE game_name = $1 AND tag_line = $2 AND region = $3 AND expires_at > NOW()
`

type GetCachedAccountParams struct {
	GameName string `json:"game_name"`
	TagLine  string `json:"tag_line"`
	Region   string `json:"region"`
}

type GetCachedAccountRow struct {
	GameName string `json:"game_name"`
	TagLine  string `json:"tag_line"`
	Region   string `json:"region"`
	Puuid    string `json:"puuid"`
}

// Account cache queries
func (q *Queries) GetCachedAccount(ctx context.Context, arg GetCachedAccountParams) (GetCachedAccountRow, error) {
	row := q.db.QueryRow(ctx, getCachedAccount, arg.GameName, arg.TagLine, arg.Region)
	var i GetCachedAccountRow
	err := row.Scan(
		&i.GameName,
		&i.TagLine,
		&i.Region,
		&i.Puuid,
	)
	return i, err
}

const getCachedGameStatus = `-- name: GetCachedGameStatus :one
SELECT puuid, region, in_game, game_id, participants
FROM riot_game_cache
WHERE puuid = $1 AND region = $2 AND expires_at > NOW()
`

type GetCachedGameStatusParams struct {
	Puuid  string `json:"puuid"`
	Region string `json:"region"`
}

type GetCachedGameStatusRow struct {
	Puuid        string      `json:"puuid"`
	Region       string      `json:"region"`
	InGame       bool        `json:"in_game"`
	GameID       pgtype.Int8 `json:"game_id"`
	Participants []byte      `json:"participants"`
}

// Game cache queries
func (q *Queries) GetCachedGameStatus(ctx context.Context, arg GetCachedGameStatusParams) (GetCachedGameStatusRow, error) {
	row := q.db.QueryRow(ctx, getCachedGameStatus, arg.Puuid, arg.Region)
	var i GetCachedGameStatusRow
	err := row.Scan(
		&i.Puuid,
		&i.Region,
		&i.InGame,
		&i.GameID,
		&i.Participants,
	)
	return i, err
}

const getEvalByGameAndSubscription = `-- name: GetEvalByGameAndSubscription :one
SELECT id, subscription_id, game_id, evaluated_at, eval_status, discord_message_id FROM evals
WHERE game_id = $1 AND subscription_id = $2
LIMIT 1
`

type GetEvalByGameAndSubscriptionParams struct {
	GameID         pgtype.Int8 `json:"game_id"`
	SubscriptionID int64       `json:"subscription_id"`
}

func (q *Queries) GetEvalByGameAndSubscription(ctx context.Context, arg GetEvalByGameAndSubscriptionParams) (Eval, error) {
	row := q.db.QueryRow(ctx, getEvalByGameAndSubscription, arg.GameID, arg.SubscriptionID)
	var i Eval
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.GameID,
		&i.EvaluatedAt,
		&i.EvalStatus,
		&i.DiscordMessageID,
	)
	return i, err
}

const getLatestEvalForSubscription = `-- name: GetLatestEvalForSubscription :one
SELECT id, subscription_id, game_id, evaluated_at, eval_status, discord_message_id FROM evals
WHERE subscription_id = $1
ORDER BY evaluated_at DESC
LIMIT 1
`

func (q *Queries) GetLatestEvalForSubscription(ctx context.Context, subscriptionID int64) (Eval, error) {
	row := q.db.QueryRow(ctx, getLatestEvalForSubscription, subscriptionID)
	var i Eval
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.GameID,
		&i.EvaluatedAt,
		&i.EvalStatus,
		&i.DiscordMessageID,
	)
	return i, err
}

const getPlayer = `-- name: GetPlayer :one
SELECT username, region, rank, top_champions, puuid, first_seen, last_updated FROM players WHERE username = $1
`

func (q *Queries) GetPlayer(ctx context.Context, username string) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayer, username)
	var i Player
	err := row.Scan(
		&i.Username,
		&i.Region,
		&i.Rank,
		&i.TopChampions,
		&i.Puuid,
		&i.FirstSeen,
		&i.LastUpdated,
	)
	return i, err
}

const getPublicTranslation = `-- name: GetPublicTranslation :one
SELECT pt.id, pt.username, pt.translation, pt.explanation, pt.language,
       p.region, pt.source_bot_id, pt.riot_verified, p.rank, p.top_champions,
       pt.upvotes, pt.downvotes, pt.created_at
FROM public_translations pt
JOIN players p ON pt.player_username = p.username
WHERE pt.id = $1
`

type GetPublicTranslationRow struct {
	ID           int64              `json:"id"`
	Username     string             `json:"username"`
	Translation  string             `json:"translation"`
	Explanation  pgtype.Text        `json:"explanation"`
	Language     string             `json:"language"`
	Region       string             `json:"region"`
	SourceBotID  pgtype.Text        `json:"source_bot_id"`
	RiotVerified bool               `json:"riot_verified"`
	Rank         pgtype.Text        `json:"rank"`
	TopChampions pgtype.Text        `json:"top_champions"`
	Upvotes      int32              `json:"upvotes"`
	Downvotes    int32              `json:"downvotes"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetPublicTranslation(ctx context.Context, id int64) (GetPublicTranslationRow, error) {
	row := q.db.QueryRow(ctx, getPublicTranslation, id)
	var i GetPublicTranslationRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Translation,
		&i.Explanation,
		&i.Language,
		&i.Region,
		&i.SourceBotID,
		&i.RiotVerified,
		&i.Rank,
		&i.TopChampions,
		&i.Upvotes,
		&i.Downvotes,
		&i.CreatedAt,
	)
	return i, err
}

const getPublicTranslationByUsername = `-- name: GetPublicTranslationByUsername :one
SELECT pt.id, pt.username, pt.translation, pt.explanation, pt.language,
       p.region, pt.source_bot_id, pt.riot_verified, p.rank, p.top_champions,
       pt.upvotes, pt.downvotes, pt.created_at
FROM public_translations pt
JOIN players p ON pt.player_username = p.username
WHERE pt.username = $1
`

type GetPublicTranslationByUsernameRow struct {
	ID           int64              `json:"id"`
	Username     string             `json:"username"`
	Translation  string             `json:"translation"`
	Explanation  pgtype.Text        `json:"explanation"`
	Language     string             `json:"language"`
	Region       string             `json:"region"`
	SourceBotID  pgtype.Text        `json:"source_bot_id"`
	RiotVerified bool               `json:"riot_verified"`
	Rank         pgtype.Text        `json:"rank"`
	TopChampions pgtype.Text        `json:"top_champions"`
	Upvotes      int32              `json:"upvotes"`
	Downvotes    int32              `json:"downvotes"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetPublicTranslationByUsername(ctx context.Context, username string) (GetPublicTranslationByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getPublicTranslationByUsername, username)
	var i GetPublicTranslationByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Translation,
		&i.Explanation,
		&i.Language,
		&i.Region,
		&i.SourceBotID,
		&i.RiotVerified,
		&i.Rank,
		&i.TopChampions,
		&i.Upvotes,
		&i.Downvotes,
		&i.CreatedAt,
	)
	return i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, discord_channel_id, server_id, lol_username, region, created_at, last_evaluated_at FROM subscriptions
WHERE id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id int64) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.DiscordChannelID,
		&i.ServerID,
		&i.LolUsername,
		&i.Region,
		&i.CreatedAt,
		&i.LastEvaluatedAt,
	)
	return i, err
}

const getSubscriptionsByChannel = `-- name: GetSubscriptionsByChannel :many
SELECT id, discord_channel_id, server_id, lol_username, region, created_at, last_evaluated_at FROM subscriptions
WHERE discord_channel_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetSubscriptionsByChannel(ctx context.Context, discordChannelID string) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByChannel, discordChannelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.DiscordChannelID,
			&i.ServerID,
			&i.LolUsername,
			&i.Region,
			&i.CreatedAt,
			&i.LastEvaluatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslation = `-- name: GetTranslation :one
SELECT id, username, translation, provider, model, created_at FROM translations
WHERE username = $1
`

func (q *Queries) GetTranslation(ctx context.Context, username string) (Translation, error) {
	row := q.db.QueryRow(ctx, getTranslation, username)
	var i Translation
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Translation,
		&i.Provider,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}

const getTranslations = `-- name: GetTranslations :many
SELECT id, username, translation, provider, model, created_at FROM translations
WHERE username = ANY($1::text[])
`

func (q *Queries) GetTranslations(ctx context.Context, dollar_1 []string) ([]Translation, error) {
	rows, err := q.db.Query(ctx, getTranslations, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Translation{}
	for rows.Next() {
		var i Translation
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Translation,
			&i.Provider,
			&i.Model,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslationsForEval = `-- name: GetTranslationsForEval :many
SELECT t.id, t.username, t.translation, t.provider, t.model, t.created_at
FROM translations t
JOIN translation_to_evals tte ON t.id = tte.translation_id
WHERE tte.eval_id = $1
`

func (q *Queries) GetTranslationsForEval(ctx context.Context, evalID int64) ([]Translation, error) {
	rows, err := q.db.Query(ctx, getTranslationsForEval, evalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Translation{}
	for rows.Next() {
		var i Translation
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Translation,
			&i.Provider,
			&i.Model,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVote = `-- name: GetVote :one
SELECT id, translation_id, ip_hash, vote, created_at FROM votes WHERE translation_id = $1 AND ip_hash = $2
`

type GetVoteParams struct {
	TranslationID int64  `json:"translation_id"`
	IpHash        string `json:"ip_hash"`
}

func (q *Queries) GetVote(ctx context.Context, arg GetVoteParams) (Vote, error) {
	row := q.db.QueryRow(ctx, getVote, arg.TranslationID, arg.IpHash)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.TranslationID,
		&i.IpHash,
		&i.Vote,
		&i.CreatedAt,
	)
	return i, err
}

const incrementDownvotes = `-- name: IncrementDownvotes :exec
UPDATE public_translations SET downvotes = downvotes + 1 WHERE id = $1
`

func (q *Queries) IncrementDownvotes(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, incrementDownvotes, id)
	return err
}

const incrementUpvotes = `-- name: IncrementUpvotes :exec
UPDATE public_translations SET upvotes = upvotes + 1 WHERE id = $1
`

func (q *Queries) IncrementUpvotes(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, incrementUpvotes, id)
	return err
}

const listAllPlayers = `-- name: ListAllPlayers :many
SELECT username, region, rank, top_champions, puuid, first_seen, last_updated FROM players ORDER BY username
`

func (q *Queries) ListAllPlayers(ctx context.Context) ([]Player, error) {
	rows, err := q.db.Query(ctx, listAllPlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.Username,
			&i.Region,
			&i.Rank,
			&i.TopChampions,
			&i.Puuid,
			&i.FirstSeen,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicFeedback = `-- name: ListPublicFeedback :many
SELECT pf.id, pf.translation_id, pf.ip_hash, pf.feedback_text, pf.created_at, pt.username, pt.translation
FROM public_feedback pf
JOIN public_translations pt ON pt.id = pf.translation_id
ORDER BY pf.created_at DESC
LIMIT $1 OFFSET $2
`

type ListPublicFeedbackParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPublicFeedbackRow struct {
	ID            int64              `json:"id"`
	TranslationID int64              `json:"translation_id"`
	IpHash        string             `json:"ip_hash"`
	FeedbackText  string             `json:"feedback_text"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	Username      string             `json:"username"`
	Translation   string             `json:"translation"`
}

func (q *Queries) ListPublicFeedback(ctx context.Context, arg ListPublicFeedbackParams) ([]ListPublicFeedbackRow, error) {
	rows, err := q.db.Query(ctx, listPublicFeedback, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublicFeedbackRow{}
	for rows.Next() {
		var i ListPublicFeedbackRow
		if err := rows.Scan(
			&i.ID,
			&i.TranslationID,
			&i.IpHash,
			&i.FeedbackText,
			&i.CreatedAt,
			&i.Username,
			&i.Translation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicTranslationsNew = `-- name: ListPublicTranslationsNew :many
SELECT pt.id, pt.username, pt.translation, pt.explanation, pt.language,
       p.region, pt.source_bot_id, pt.riot_verified, p.rank, p.top_champions,
       pt.upvotes, pt.downvotes, pt.created_at
FROM public_translations pt
JOIN players p ON pt.player_username = p.username
WHERE ($1::text = '' OR p.region = $1)
  AND ($2::text = '' OR pt.language = $2)
ORDER BY pt.created_at DESC
LIMIT $3 OFFSET $4
`

type ListPublicTranslationsNewParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type ListPublicTranslationsNewRow struct {
	ID           int64              `json:"id"`
	Username     string             `json:"username"`
	Translation  string             `json:"translation"`
	Explanation  pgtype.Text        `json:"explanation"`
	Language     string             `json:"language"`
	Region       string             `json:"region"`
	SourceBotID  pgtype.Text        `json:"source_bot_id"`
	RiotVerified bool               `json:"riot_verified"`
	Rank         pgtype.Text        `json:"rank"`
	TopChampions pgtype.Text        `json:"top_champions"`
	Upvotes      int32              `json:"upvotes"`
	Downvotes    int32              `json:"downvotes"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListPublicTranslationsNew(ctx context.Context, arg ListPublicTranslationsNewParams) ([]ListPublicTranslationsNewRow, error) {
	rows, err := q.db.Query(ctx, listPublicTranslationsNew,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublicTranslationsNewRow{}
	for rows.Next() {
		var i ListPublicTranslationsNewRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Translation,
			&i.Explanation,
			&i.Language,
			&i.Region,
			&i.SourceBotID,
			&i.RiotVerified,
			&i.Rank,
			&i.TopChampions,
			&i.Upvotes,
			&i.Downvotes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicTranslationsTop = `-- name: ListPublicTranslationsTop :many
SELECT pt.id, pt.username, pt.translation, pt.explanation, pt.language,
       p.region, pt.source_bot_id, pt.riot_verified, p.rank, p.top_champions,
       pt.upvotes, pt.downvotes, pt.created_at
FROM public_translations pt
JOIN players p ON pt.player_username = p.username
WHERE ($1::text = '' OR p.region = $1)
  AND ($2::text = '' OR pt.language = $2)
  AND pt.created_at > $5
ORDER BY (pt.upvotes - pt.downvotes) DESC, pt.created_at DESC
LIMIT $3 OFFSET $4
`

type ListPublicTranslationsTopParams struct {
	Column1   string             `json:"column_1"`
	Column2   string             `json:"column_2"`
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type ListPublicTranslationsTopRow struct {
	ID           int64              `json:"id"`
	Username     string             `json:"username"`
	Translation  string             `json:"translation"`
	Explanation  pgtype.Text        `json:"explanation"`
	Language     string             `json:"language"`
	Region       string             `json:"region"`
	SourceBotID  pgtype.Text        `json:"source_bot_id"`
	RiotVerified bool               `json:"riot_verified"`
	Rank         pgtype.Text        `json:"rank"`
	TopChampions pgtype.Text        `json:"top_champions"`
	Upvotes      int32              `json:"upvotes"`
	Downvotes    int32              `json:"downvotes"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListPublicTranslationsTop(ctx context.Context, arg ListPublicTranslationsTopParams) ([]ListPublicTranslationsTopRow, error) {
	rows, err := q.db.Query(ctx, listPublicTranslationsTop,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
		arg.CreatedAt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublicTranslationsTopRow{}
	for rows.Next() {
		var i ListPublicTranslationsTopRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Translation,
			&i.Explanation,
			&i.Language,
			&i.Region,
			&i.SourceBotID,
			&i.RiotVerified,
			&i.Rank,
			&i.TopChampions,
			&i.Upvotes,
			&i.Downvotes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlayerStats = `-- name: UpdatePlayerStats :exec
UPDATE players SET rank = $2, top_champions = $3, last_updated = NOW()
WHERE username = $1
`

type UpdatePlayerStatsParams struct {
	Username     string      `json:"username"`
	Rank         pgtype.Text `json:"rank"`
	TopChampions pgtype.Text `json:"top_champions"`
}

func (q *Queries) UpdatePlayerStats(ctx context.Context, arg UpdatePlayerStatsParams) error {
	_, err := q.db.Exec(ctx, updatePlayerStats, arg.Username, arg.Rank, arg.TopChampions)
	return err
}

const updateSubscriptionLastEvaluatedAt = `-- name: UpdateSubscriptionLastEvaluatedAt :exec
UPDATE subscriptions
SET last_evaluated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateSubscriptionLastEvaluatedAt(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateSubscriptionLastEvaluatedAt, id)
	return err
}

const upsertPlayer = `-- name: UpsertPlayer :one


INSERT INTO players (username, region, rank, top_champions, puuid)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (username) DO UPDATE SET
    region = EXCLUDED.region,
    rank = COALESCE(EXCLUDED.rank, players.rank),
    top_champions = COALESCE(EXCLUDED.top_champions, players.top_champions),
    puuid = COALESCE(EXCLUDED.puuid, players.puuid),
    last_updated = NOW()
RETURNING username, region, rank, top_champions, puuid, first_seen, last_updated
`

type UpsertPlayerParams struct {
	Username     string      `json:"username"`
	Region       string      `json:"region"`
	Rank         pgtype.Text `json:"rank"`
	TopChampions pgtype.Text `json:"top_champions"`
	Puuid        pgtype.Text `json:"puuid"`
}

// ===========================================
// Companion Website Queries
// ===========================================
// Player queries
func (q *Queries) UpsertPlayer(ctx context.Context, arg UpsertPlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, upsertPlayer,
		arg.Username,
		arg.Region,
		arg.Rank,
		arg.TopChampions,
		arg.Puuid,
	)
	var i Player
	err := row.Scan(
		&i.Username,
		&i.Region,
		&i.Rank,
		&i.TopChampions,
		&i.Puuid,
		&i.FirstSeen,
		&i.LastUpdated,
	)
	return i, err
}

const upsertPublicTranslation = `-- name: UpsertPublicTranslation :one

INSERT INTO public_translations (username, translation, explanation, language, player_username, source_bot_id, riot_verified)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (username) DO UPDATE SET
    translation = EXCLUDED.translation,
    explanation = EXCLUDED.explanation,
    language = EXCLUDED.language,
    player_username = EXCLUDED.player_username,
    source_bot_id = EXCLUDED.source_bot_id,
    riot_verified = EXCLUDED.riot_verified
RETURNING id, username, translation, explanation, language, player_username, source_bot_id, riot_verified, upvotes, downvotes, created_at
`

type UpsertPublicTranslationParams struct {
	Username       string      `json:"username"`
	Translation    string      `json:"translation"`
	Explanation    pgtype.Text `json:"explanation"`
	Language       string      `json:"language"`
	PlayerUsername string      `json:"player_username"`
	SourceBotID    pgtype.Text `json:"source_bot_id"`
	RiotVerified   bool        `json:"riot_verified"`
}

// Public translation queries (JOIN against players for region/rank/top_champions)
func (q *Queries) UpsertPublicTranslation(ctx context.Context, arg UpsertPublicTranslationParams) (PublicTranslation, error) {
	row := q.db.QueryRow(ctx, upsertPublicTranslation,
		arg.Username,
		arg.Translation,
		arg.Explanation,
		arg.Language,
		arg.PlayerUsername,
		arg.SourceBotID,
		arg.RiotVerified,
	)
	var i PublicTranslation
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Translation,
		&i.Explanation,
		&i.Language,
		&i.PlayerUsername,
		&i.SourceBotID,
		&i.RiotVerified,
		&i.Upvotes,
		&i.Downvotes,
		&i.CreatedAt,
	)
	return i, err
}

const upsertVote = `-- name: UpsertVote :one
INSERT INTO votes (translation_id, ip_hash, vote)
VALUES ($1, $2, $3)
ON CONFLICT (translation_id, ip_hash) DO UPDATE SET vote = $3
RETURNING id, translation_id, ip_hash, vote, created_at
`

type UpsertVoteParams struct {
	TranslationID int64  `json:"translation_id"`
	IpHash        string `json:"ip_hash"`
	Vote          int16  `json:"vote"`
}

func (q *Queries) UpsertVote(ctx context.Context, arg UpsertVoteParams) (Vote, error) {
	row := q.db.QueryRow(ctx, upsertVote, arg.TranslationID, arg.IpHash, arg.Vote)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.TranslationID,
		&i.IpHash,
		&i.Vote,
		&i.CreatedAt,
	)
	return i, err
}
