// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEval = `-- name: CreateEval :one
INSERT INTO evals (subscription_id, eval_status, discord_message_id)
VALUES ($1, $2, $3)
RETURNING id, subscription_id, evaluated_at, eval_status, discord_message_id
`

type CreateEvalParams struct {
	SubscriptionID   int64       `json:"subscription_id"`
	EvalStatus       string      `json:"eval_status"`
	DiscordMessageID pgtype.Text `json:"discord_message_id"`
}

func (q *Queries) CreateEval(ctx context.Context, arg CreateEvalParams) (Eval, error) {
	row := q.db.QueryRow(ctx, createEval, arg.SubscriptionID, arg.EvalStatus, arg.DiscordMessageID)
	var i Eval
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.EvaluatedAt,
		&i.EvalStatus,
		&i.DiscordMessageID,
	)
	return i, err
}

const createFeedback = `-- name: CreateFeedback :one
INSERT INTO feedback (discord_message_id, feedback_text)
VALUES ($1, $2)
RETURNING id, discord_message_id, feedback_text, created_at
`

type CreateFeedbackParams struct {
	DiscordMessageID string `json:"discord_message_id"`
	FeedbackText     string `json:"feedback_text"`
}

func (q *Queries) CreateFeedback(ctx context.Context, arg CreateFeedbackParams) (Feedback, error) {
	row := q.db.QueryRow(ctx, createFeedback, arg.DiscordMessageID, arg.FeedbackText)
	var i Feedback
	err := row.Scan(
		&i.ID,
		&i.DiscordMessageID,
		&i.FeedbackText,
		&i.CreatedAt,
	)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (discord_channel_id, lol_username)
VALUES ($1, $2)
ON CONFLICT (discord_channel_id, lol_username) DO NOTHING
RETURNING id, discord_channel_id, lol_username, created_at
`

type CreateSubscriptionParams struct {
	DiscordChannelID string `json:"discord_channel_id"`
	LolUsername      string `json:"lol_username"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription, arg.DiscordChannelID, arg.LolUsername)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.DiscordChannelID,
		&i.LolUsername,
		&i.CreatedAt,
	)
	return i, err
}

const createTranslation = `-- name: CreateTranslation :one
INSERT INTO translations (username, translation)
VALUES ($1, $2)
ON CONFLICT (username) DO UPDATE SET translation = $2
RETURNING id, username, translation, created_at
`

type CreateTranslationParams struct {
	Username    string `json:"username"`
	Translation string `json:"translation"`
}

func (q *Queries) CreateTranslation(ctx context.Context, arg CreateTranslationParams) (Translation, error) {
	row := q.db.QueryRow(ctx, createTranslation, arg.Username, arg.Translation)
	var i Translation
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Translation,
		&i.CreatedAt,
	)
	return i, err
}

const createTranslationToEval = `-- name: CreateTranslationToEval :exec
INSERT INTO translation_to_evals (translation_id, eval_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type CreateTranslationToEvalParams struct {
	TranslationID int64 `json:"translation_id"`
	EvalID        int64 `json:"eval_id"`
}

func (q *Queries) CreateTranslationToEval(ctx context.Context, arg CreateTranslationToEvalParams) error {
	_, err := q.db.Exec(ctx, createTranslationToEval, arg.TranslationID, arg.EvalID)
	return err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
DELETE FROM subscriptions
WHERE discord_channel_id = $1 AND lol_username = $2
`

type DeleteSubscriptionParams struct {
	DiscordChannelID string `json:"discord_channel_id"`
	LolUsername      string `json:"lol_username"`
}

func (q *Queries) DeleteSubscription(ctx context.Context, arg DeleteSubscriptionParams) error {
	_, err := q.db.Exec(ctx, deleteSubscription, arg.DiscordChannelID, arg.LolUsername)
	return err
}

const getAllSubscriptions = `-- name: GetAllSubscriptions :many
SELECT id, discord_channel_id, lol_username, created_at FROM subscriptions
ORDER BY created_at DESC
`

func (q *Queries) GetAllSubscriptions(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getAllSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.DiscordChannelID,
			&i.LolUsername,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestEvalForSubscription = `-- name: GetLatestEvalForSubscription :one
SELECT id, subscription_id, evaluated_at, eval_status, discord_message_id FROM evals
WHERE subscription_id = $1
ORDER BY evaluated_at DESC
LIMIT 1
`

func (q *Queries) GetLatestEvalForSubscription(ctx context.Context, subscriptionID int64) (Eval, error) {
	row := q.db.QueryRow(ctx, getLatestEvalForSubscription, subscriptionID)
	var i Eval
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.EvaluatedAt,
		&i.EvalStatus,
		&i.DiscordMessageID,
	)
	return i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, discord_channel_id, lol_username, created_at FROM subscriptions
WHERE id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id int64) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.DiscordChannelID,
		&i.LolUsername,
		&i.CreatedAt,
	)
	return i, err
}

const getSubscriptionsByChannel = `-- name: GetSubscriptionsByChannel :many
SELECT id, discord_channel_id, lol_username, created_at FROM subscriptions
WHERE discord_channel_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetSubscriptionsByChannel(ctx context.Context, discordChannelID string) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByChannel, discordChannelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.DiscordChannelID,
			&i.LolUsername,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslation = `-- name: GetTranslation :one
SELECT id, username, translation, created_at FROM translations
WHERE username = $1
`

func (q *Queries) GetTranslation(ctx context.Context, username string) (Translation, error) {
	row := q.db.QueryRow(ctx, getTranslation, username)
	var i Translation
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Translation,
		&i.CreatedAt,
	)
	return i, err
}

const getTranslations = `-- name: GetTranslations :many
SELECT id, username, translation, created_at FROM translations
WHERE username = ANY($1::text[])
`

func (q *Queries) GetTranslations(ctx context.Context, dollar_1 []string) ([]Translation, error) {
	rows, err := q.db.Query(ctx, getTranslations, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Translation{}
	for rows.Next() {
		var i Translation
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Translation,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslationsForEval = `-- name: GetTranslationsForEval :many
SELECT t.id, t.username, t.translation, t.created_at
FROM translations t
JOIN translation_to_evals tte ON t.id = tte.translation_id
WHERE tte.eval_id = $1
`

func (q *Queries) GetTranslationsForEval(ctx context.Context, evalID int64) ([]Translation, error) {
	rows, err := q.db.Query(ctx, getTranslationsForEval, evalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Translation{}
	for rows.Next() {
		var i Translation
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Translation,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
